1. The worst case asymptotic performance for the sort provided is O(n^2). This is because, regardless of how the elements in the array are arranged, sort will have an index i run from 0 to n-2 and an index j run from 1 to n-1 for each i value respectively. The index j thus visits n-1 + n-2 + n-3... + 1 + 0 other indices in the array. The index i visits a total of n - 1 values in the array. The total of these two is equal to ((n-1+1)(n-1)/2) + n-1, which results in a value in the order of n^2. This means that the asymptotic complexity of sort is O(n^2).
The worst case asymptotic performance for the insertion sort is O(n^2) (Note: I am using the insertion sort algorithm provided in the lecture notes). This occurs when the array is sorted in the reverse order. In this case, the inner for loop does not break until j = 0, because a[j-1] will always be greater than k, the value of reference. At each iteration, insertion sort will place the reference value at the very front of the array, but it will also visit every index between the index of the reference value and the index 0, and compare the two values. This means that, for the index i = 1, insertion sort will make 1 comparison, comparing it to index 0. For index i = 2, insertion sort will make 2 comparisons, comparing it to the index 1 and the index 0. For the last index n, insertion sort will make n comparisons and place the smallest value (since the array is in reverse order) in the front. This totals to (n*(n-1)/2), which gives O(n) complexity.
Their worst case asymptotic performances are equal.
In the best case asymptotic performance for sort, sort will ALSO have asymptotic complexity of O(n^2). This is because, when calculating the asymptotic performance of sort, the same logic applies regardless of the contents or ordering of the array. The guard of the for loops inside sort are independent of how each element appears to its neighbors or to any reference value; they are only broken upon reaching a certain index. Therefore, the best, and worst, and for that matter, every case of sort has an asymptotic complexity of O(n^2).
The best case asymptotic performance for insertion sort is when the two arrays are already sorted. In the inner for loop of the insertion sort, one of the conditions is that a[j-1] > k. The integer J always starts out with a value of i, for whichever value i represents the iteration of the outer loop that is currently being processed. K is given the value a[i]. In a sorted list, a[i-1] < a[i] for all i in the bounds of the array that have a previous element; this is the definition of a sorted list. Thus, a[i-1] < a[i] and we can substitute j for i and K for a[i] because these values represent the first iteration of the inner for loop. We can see that a[j-1] < K, which contradicts the inner for loop guard of a[j-1] > K. This means the inner for loop will never run for any i in the bounds of the array that has a previous value. The absence of a previous value is not something we have to worry about since i starts at 1. Since the inner loop never executes, the only index we observe is the index i. This means that the best case asymptotic performance for insert sort is the number of iterations of i, which runs from 1->n-1, resulting in O(n) or linear complexity. 
Insertion sort has a faster best-case asymptotic complexity.
I would expect insertion sort to be faster because in a typical randomized case, the time taken would fall somewhere between the best-case and worst-case asymptotic performances. Since sort has the same performance regardless of the orientation of the array, the asymptotic performance of sort will always be O(n^2). However, in practice, insertion sort will likely not shift every element to the first index, which would be the only instance in which it mimics O(n^2) asymptotic complexity. One of the clauses of the loop invariant of the insertion sort is that for each i, all elements to the left of i are sorted. At each iteration, insertion sort places the value at the index i at the correct spot in this sorted group. This is likely to be somewhere between the first and last indices of all elements before I, simply because placing everything at the first index would mean the array is sorted in reverse order, and placing everything in the last index would mean the array is already sorted. Since those two possibilities are 2 out of the n! possible permutations of all numbers in the array (assuming no duplicates) simple probability theory states that the array is likely to NOT be one of these two orientations, leaving insertion sort to very likely be better than sort.


