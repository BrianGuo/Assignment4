# Assignment4

1. Our abstract Syntax tree, as a data structure, will have a Program Node as its root node. This node will store an arraylist of Nodes, specifically of type RuleNode. RuleNode is another instance of Node that represents the relationship between a condition and a command. Thus, Rule will have, as fields, a ConditionNode and a CommandNode. The condition Node represents a condition and thus must evaluate to True or False. Since ConditionNode itself is an interface, when I say ConditionNode, I really mean the classes that implement it, which are BinaryCondition and Relation. A BinaryCondition holds two instances of condition as fields and links them with an operator of && or ||. If multiple BinaryConditions are needed (...||...&&...), this is accounted for by the fact that a binaryop is a condition, so BinaryCondition can store a BinaryCondition as one of its fields. A Relation holds two expressions and links them with a relational operator (<, >, ==, etc.). The expression class will be discussed in detail later. The condition, if True, will permit Rule to evaluate and perform the commandNode. The commandNode holds a list of updates and an action, initially set to null. Update itself is a Node and thus implements the Node interface. It symbolizes the relationship "mem[expr] := expr", and thus holds two nodes: a MemoryNode and an Expression Node. The ActionNode of a commandNode is a Node that symbolizes one unique action (wait, forward, backward, etc.) and holds a String representing which Action it is, as well as a possible expression, originally set to null, since some actions may contain expressions. An expression is a sub-interface of Node which contains two classes: NumberNode and BinaryOperation. A NumberNode is intuitively a Node representing one number. A BinaryOperation is a node which contains two expressions and one operation (+,-,/,*) which it applies to them. Therefore, an expression will ALWAYS evaluate to a number, if the inputs are correct. This is the structure of the abstract syntax tree.

2. As we have shown, we have thought about the relationship between a Node and the sub-Node it should point to. Mutation, I imagine, would be one of the rather difficult processes to implement. Mutations themselves are described in detail in the project specification and one should run into no problems if he simply follows what is written. Deciding whether or not to mutate is simply a matter of calling Math.random(), as is deciding whether to mutate an attribute or a rule set. It is giving each node an equal probability, I believe, which is the most difficult task. I would like to find some way to do it without traversing through the tree and counting each individual Node, but I do not, as of yet, see a way to. Considering that there may be up to 999 rules, though, I imagine that counting a rule and its sub-Nodes may be rather slow. Still, perhaps it is the fact that the number of rules is arbitrary that makes it difficult to find a method that gives each node an equal opportunity, without counting each Node. I imagine that the size function of Program is what would be used to give each node an equal opportunity.

3. Our work is divided primarily through packages. The entire AST package will be handled by Brian Guo, while Parsing will be handled by Max Zhou. In this project, when we say "the entire package," we mean that if a method needs to be implemented in a certain package, it will be implemented by that respective person. The main method, since it involves primarily parsing the input into tokens, will be handled by Max Zhou. The written problems will be coordinated by splitting the work and then checking and discussing the responses of the other person. This method of division of work will involve some gray-areas, which is something we are both aware of. For instance, parserImpl.java will need to call the appropriate constructors, which is something that will be discussed between the two of us in the midst of our project. Since we are using github branches to divide tasks, we can easily check each other's implementation of certain algorithms.

4. The implementation of the fault injector will provide us with many sample critters that we can test to make sure our Pretty-Printer and Parser, at the very least, compiles. To test that it produces the right output, we believe Pretty-Printer and Parser can test each other. If we can keep track of what mutaton was made to which Node in each test, we can check where the process fails. The testing should involve mutating a critter, pretty-printing the output, parsing the print, and checking the resulting generated tree to see if it matches the mutated tree prior to pretty-printing. If they do not, we can check the pretty-printed document to see if the process failed in the pretty-printing or in the parsing.
